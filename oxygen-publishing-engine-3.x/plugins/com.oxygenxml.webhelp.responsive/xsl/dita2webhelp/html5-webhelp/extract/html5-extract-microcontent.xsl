<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:oxygen="http://www.oxygenxml.com/functions"
	xmlns:micro="http://www.oxygenxml.com/ns/webhelp/microcontent"
	xmlns:dita-ot="http://dita-ot.sourceforge.net/ns/201007/dita-ot"
  xmlns:relpath="http://dita2indesign/functions/relpath"
	exclude-result-prefixes="xs dita-ot oxygen relpath" version="2.0">



	<!-- 
    Extracts a microcontent file for each topic that contains questions,
    either set as a data element in the prolog, or through a qatopic,
    or by setting them at element level.
   -->
  <xsl:param name="EXTRACT_MICROCONTENT" select="'no'"/>

	<xsl:param name="TEMPDIR_URL"/>
	<xsl:param name="OUTDIR"/>

	<xsl:include href="html5-extract-microcontent-from-prolog.xsl"/>
	<xsl:include href="html5-extract-microcontent-from-qatopic.xsl"/>
	<xsl:include href="html5-extract-microcontent-from-body.xsl"/>

	<!-- 
  ========================================================
  Templates that apply when generating the micro-content
  file
  ========================================================
   -->

  <xsl:variable name="extract.microcontent" 
      select="$EXTRACT_MICROCONTENT = 'yes' or 
              $EXTRACT_MICROCONTENT = 'true'" 
      as="xs:boolean"/>
      
	<xsl:template name="extract-microcontent">

    <xsl:if test="$extract.microcontent">
  		<!-- Collect all the questions from the prolog -->
  		<xsl:variable name="questions-in-prolog"
  			select="/*[contains(@class, ' topic/topic ')]/*[contains(@class, ' topic/prolog ')]/*[contains(@class, ' topic/metadata ')]/*[contains(@class, ' topic/data ')][@name = 'oxy:question']"/>
  
  		<!-- Collect all the questions from the body -->
  		<xsl:variable name="questions-in-body"
  			select="/*[contains(@class, ' topic/topic ')]/*[contains(@class, ' topic/body ')]//*[contains(@class, ' topic/data ')][@name = 'oxy:question']"/>
  
  		<xsl:variable name="is-qatopic" select="count(/*[contains(@class, ' qatopic/qatopic ')]) > 0"/>
  
  		<!-- Check if the topic is a qatopic or there are questions -->
  		<xsl:if test="
  				count($questions-in-prolog) > 0 or
  				count($questions-in-body) > 0 or
  				$is-qatopic">
  
        
        
  			<xsl:result-document href="{concat(base-uri(), '.microcontent')}">
  				<micro:microcontent>
  
  					<xsl:if test="count($questions-in-prolog) > 0">
  						<xsl:call-template name="extract-microcontent-from-prolog">
  							<xsl:with-param name="questions-in-prolog" select="$questions-in-prolog"/>
  						</xsl:call-template>
  					</xsl:if>
  
  					<xsl:if test="count($questions-in-body) > 0">
  						<xsl:call-template name="extract-microcontent-from-body"/>
  					</xsl:if>
  
  					<xsl:if test="$is-qatopic">
  						<xsl:call-template name="extract-microcontent-from-qatopic"/>
  					</xsl:if>
  
  				</micro:microcontent>
  			</xsl:result-document>
  
  		</xsl:if>
    </xsl:if>
	</xsl:template>


	<!-- 
  ========================================================
  Templates that apply when generating the HTML
  file
  ========================================================
   -->

	<!-- 
    Generate an ID on the parent of the question that do not have an ID. 
    This is necessary in order to create links to these elements,
    from the microcontent (let say the chatbot identifies an answer, it may
    very well provide a link to the answer). 
   -->
	<xsl:template name="add-id-for-microcontent">
		<!-- 
      Captures the HTML fragment generated by normal HTML transformation. 
      -->
		<xsl:variable name="html-parent-content">
			<xsl:next-match/>
		</xsl:variable>

		<!-- 
      Copies the fragment, adding the generated ID attribute 
      on the HTML section corresponding to the parent of the question..       
      -->
		<xsl:apply-templates select="$html-parent-content" mode="add-id-for-microcontent">
			<xsl:with-param name="id" select="
					dita-ot:generate-id(
					ancestor::*[contains(@class, ' topic/topic ')][1]/@id,
					generate-id(.))" tunnel="yes"/>
		</xsl:apply-templates>
	</xsl:template>

	<!-- Matches HTML nodes from the generated fragment. -->
	<xsl:template match="*[count(ancestor::*) = 0]" mode="add-id-for-microcontent">
		<xsl:param name="id" tunnel="yes"/>
		<xsl:copy>
			<xsl:apply-templates select="@*" mode="#current"/>
			<xsl:attribute name="id" select="$id"/>
			<xsl:apply-templates select="node()" mode="#current"/>
		</xsl:copy>
	</xsl:template>

	<!-- Copy template. -->
	<xsl:template match="node() | @*" mode="add-id-for-microcontent">
		<xsl:copy>
			<xsl:apply-templates select="node() | @*" mode="#current"/>
		</xsl:copy>
	</xsl:template>


  <xsl:function name="oxygen:get-current-html-file-name">
    <xsl:param name="node"/>
    
    <xsl:message select="relpath:unencodeUri(document-uri($node))"/>
    <xsl:message select="relpath:unencodeUri($TEMPDIR_URL)"/>
    <xsl:call-template name="replace-extension">
      <xsl:with-param name="filename" 
        select="substring-after(relpath:unencodeUri(document-uri($node)), 
                                relpath:unencodeUri($TEMPDIR_URL))"/>
      <xsl:with-param name="extension" select="$OUTEXT"/>
    </xsl:call-template>
  </xsl:function>
  
</xsl:stylesheet>
