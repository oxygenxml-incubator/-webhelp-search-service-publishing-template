[
  {
    "title": "Publishing your documentation with WebHelp Responsive using GitHub Actions",
    "shortDescription": "How to use GitHub Actions workflows in order to build documentation in WebHelp Responsive format How to publish documentation build on Netlify using GitHub Actions",
    "keywords": [],
    "contents": "Publishing your documentation with WebHelp Responsive using GitHub Actions How to use GitHub actions in order to build documentation and deploy it to Netlify How to use GitHub Actions to run a WebHelp Responsive transformation How to use GitHub Actions workflows in order to build documentation in WebHelp Responsive format Access \"Actions\" tab in your repository on GitHub Press \"New workflow\" button in the left side of the page Choose \"Simple workflow\" template and press \"Configure\" button Delete the whole content of the file and let's begin writing our workflow Firstly, we'll give a name for our workflow name: CI Then we have to add some triggers when workflow will be executed name: CI\non:\n  push:\n    branches:\n      - master Let's write our job, we have to specify the name and the version of the OS name: CI\non:\n  push:\n    branches:\n      - master\njobs:\n  build-dita-and-deploy-netlify:\n    name: Build DITA WebHelp Responsive and deploy to Netlify\n    runs-on: ubuntu-latest The first step of the job will be to checkout the current branch of repository so it can access repository files name: CI\non:\n  push:\n    branches:\n      - master\njobs:\n  build-dita-and-deploy-netlify:\n    name: Build DITA WebHelp Responsive and deploy to Netlify\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git checkout\n        uses: actions/checkout@v2 Create a file containing licensekey.txt so we can use WebHelp Responsive plugin for DITA-OT, we'll take it from repository secrets name: CI\non:\n  push:\n    branches:\n      - master\njobs:\n  build-dita-and-deploy-netlify:\n    name: Build DITA WebHelp Responsive and deploy to Netlify\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git checkout\n        uses: actions/checkout@v2\n      \n      - name: Extract license from secrets\n        run: |\n          echo \"$OPE_LICENSE\" > licensekey.txt\n        env:\n          OPE_LICENSE: ${{ secrets.OPE_LICENSE }} Then we have to download the engine name: CI\non:\n  push:\n    branches:\n      - master\njobs:\n  build-dita-and-deploy-netlify:\n    name: Build DITA WebHelp Responsive and deploy to Netlify\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git checkout\n        uses: actions/checkout@v2\n      \n      - name: Extract license from secrets\n        run: |\n          echo \"$OPE_LICENSE\" > licensekey.txt\n        env:\n          OPE_LICENSE: ${{ secrets.OPE_LICENSE }}\n        \n      - name: Download the engine\n        run: |\n            sudo wget \"http://mirror.oxygenxml.com/maven-nightly/com/oxygenxml/oxygen-publishing-engine-3.x/25.0-SNAPSHOT/oxygen-publishing-engine-3.x-25.0-SNAPSHOT-package-full.zip\"\n            sudo apt-get install unzip\n            sudo unzip oxygen-publishing-engine-3.x-25.0-SNAPSHOT-package-full.zip\n            sudo cp licensekey.txt oxygen-publishing-engine-3.x/licensekey.txt Upon downloading unzip it by adding these commands(newline) sudo apt-get install unzip\nsudo unzip oxygen-publishing-engine-3.x-25.0-SNAPSHOT-package-full.zip Finally, copy the licensekey.txt file we created into root folder of engine by adding this line sudo cp licensekey.txt oxygen-publishing-engine-3.x/licensekey.txt The last step will be to build the documentation by using dita.bat. Go to oxygen-publishing-engine-3.x/bin - name: Build WebHelp Responsive\n        run: |\n            cd oxygen-publishing-engine-3.x/bin Add this line in order to get documentation built sudo ./dita --input=inputPath --format=webhelp-responsive -Dwebhelp.publishing.template=../../templates/webhelp-documentation-template --output=outputPath Our final workflow should look like this name: CI\non:\n  push:\n    branches:\n      - master\njobs:\n  build-dita-and-deploy-netlify:\n    name: Build DITA WebHelp Responsive and deploy to Netlify\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git checkout\n        uses: actions/checkout@v2\n      \n      - name: Extract license from secrets\n        run: |\n          echo \"$OPE_LICENSE\" > licensekey.txt\n        env:\n          OPE_LICENSE: ${{ secrets.OPE_LICENSE }}\n        \n      - name: Download the engine\n        run: |\n            sudo wget \"http://mirror.oxygenxml.com/maven-nightly/com/oxygenxml/oxygen-publishing-engine-3.x/25.0-SNAPSHOT/oxygen-publishing-engine-3.x-25.0-SNAPSHOT-package-full.zip\"\n            sudo apt-get install unzip\n            sudo unzip oxygen-publishing-engine-3.x-25.0-SNAPSHOT-package-full.zip\n            sudo cp licensekey.txt oxygen-publishing-engine-3.x/licensekey.txt\n            \n      - name: Build WebHelp Responsive\n        run: |\n            cd oxygen-publishing-engine-3.x/bin\n            sudo ./dita --input=inputPath --format=webhelp-responsive -Dwebhelp.publishing.template=../../templates/webhelp-documentation-template --output=outputPath Publishing documentation on Netlify How to publish documentation build on Netlify using GitHub Actions We have to create a Netlify account, visit https://www.netlify.com In the \"overview\" tab after creating your account, press \"Add new site\" button and select \"Deploy manually\" Add any files you want because eventually they will be changed by GitHub Actions workflow After that go back to \"overview\" tab and press on your site Click \"site settings\" Copy the \"Site ID\" and add it to secrets in your GitHub repository Press on your profile picture and select \"User settings\" Select \"Applications\" tab in the left side of the page Create a new access token Give it a name and add its value to the secrets in your Github repository We're done with Netlify, now go to \"Actions\" tab in your GitHub repository and edit the workflow you've created in the previous task Add these lines at the end of the file and type in your secrets and --dir(--dir is the website's folder, in your case \"outputPath\" from the previous task\") - name: Deploy to netlify\n        uses: netlify/actions/cli@master\n        env:\n          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}\n          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}\n        with:\n          args: deploy --dir=outputPath --prod\n          secrets: '[\"NETLIFY_AUTH_TOKEN\", \"NETLIFY_SITE_ID\"]' Save the workflow file and we're done, your workflow should look now like this name: CI\non:\n  push:\n    branches:\n      - master\njobs:\n  build-dita-and-deploy-netlify:\n    name: Build DITA WebHelp Responsive and deploy to Netlify\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git checkout\n        uses: actions/checkout@v2\n      \n      - name: Extract license from secrets\n        run: |\n          echo \"$OPE_LICENSE\" > licensekey.txt\n        env:\n          OPE_LICENSE: ${{ secrets.OPE_LICENSE }}\n        \n      - name: Download the engine\n        run: |\n            sudo wget \"http://mirror.oxygenxml.com/maven-nightly/com/oxygenxml/oxygen-publishing-engine-3.x/25.0-SNAPSHOT/oxygen-publishing-engine-3.x-25.0-SNAPSHOT-package-full.zip\"\n            sudo apt-get install unzip\n            sudo unzip oxygen-publishing-engine-3.x-25.0-SNAPSHOT-package-full.zip\n            sudo cp licensekey.txt oxygen-publishing-engine-3.x/licensekey.txt\n            \n      - name: Build WebHelp Responsive\n        run: |\n            cd oxygen-publishing-engine-3.x/bin\n            sudo ./dita --input=../../doc/flowers/flowers.ditamap --format=webhelp-responsive -Dwebhelp.publishing.template=../../templates/webhelp-documentation-template --output=../../doc/flowers/out\n            \n      - name: Deploy to netlify\n        uses: netlify/actions/cli@master\n        env:\n          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}\n          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}\n        with:\n          args: deploy --dir=outputPath --prod\n          secrets: '[\"NETLIFY_AUTH_TOKEN\", \"NETLIFY_SITE_ID\"]'",
    "objectID": "https://sweet-beignet-8a9e20.netlify.app/topics/publishing_your_documentation_with_webhelp_responsive_using_github_actions.html"
  },
  {
    "title": "Crawling data and use it with Algolia",
    "shortDescription": "Usually we don't use HTML crawler separately but in case you would like to, here are all the possible methods! We created our HTML crawler using JSoup library. For our custom search service in WebHelp we used Algolia and its API.",
    "keywords": [],
    "contents": "Crawling data and use it with Algolia How to use HTML crawler and why do we need it for Algolia? HTML Crawler Usually we don't use HTML crawler separately but in case you would like to, here are all the possible methods! We created our HTML crawler using JSoup library. How to use Crawler and what's the goal of that class? First of all we have to create an instance of Crawler and send into constructor URL to be crawled, Base URL and isFile argument. We use Base URL in order to not get out of bounds. isFile is a boolean that tells the Cralwer if we're working with files or websites, by default it is set to false so you can skip it. Crawler crawler = new Crawler(url, baseUrl, isFile); // Or\nCrawler crawler = new Crawler(url, baseUrl); //By default \"isFile\" is false. To start the crawler you should call crawl() method, it doesn't receive any arguments. crawler.crawl(); After that all we're all set. Now you could access the crawled data and use it for your personal purposes. To get crawled pages we should call getCrawledPages() method. It retuns a List of Pages. Page is a created by us class that stores page's url, title, keywords and contents. crawler.getCrawledPages(); So the whole cycle would look like this: Crawler crawler = new Crawler(url, baseUrl, isFile);\ncrawler.crawl();\nList<Page> pages = crawler.getCrawledPages(); List of all the methods and explanations: /**\n* Constructor with url and baseUrl parameters.\n* \n* @param url     is the page that should be crawled for data.\n* @param baseUrl is the parent that is used to not go out of bounds.\n* \n* @throws MalformedURLException if problems with initialization of URL\n*                               occurred.\n*/\npublic Crawler(final String url, final String baseUrl) throws MalformedURLException\n\n/**\n* Constructor with url, baseUrl and isFile parameters.\n* \n* @param url     is the page that should be crawled for data.\n* @param baseUrl is the parent that is used to not go out of bounds.\n* @param isFile  is the state of URL\n* \n* @throws MalformedURLException if problems with initialization of URL\n*                               occurred.\n*/\npublic Crawler(final String url, final String baseUrl, final boolean isFile) throws MalformedURLException\n\n/**\n* @return start url that should be crawled for data.\n*/\npublic String getUrl()\n\n/**\n* @return base url that is used to not go out of parent's bounds.\n*/\npublic String getBaseUrl()\n\n/**\n* @return true if URL is a file and false otherwise.\n*/\npublic boolean isFile()\n\n/**\n* @param the value to set to \"isFile\" flag.\n*/\npublic void setIsFile(final boolean isFile)\n\n/**\n* @return list of visited urls after the crawl.\n*/\npublic List<String> getVisitedUrls()\n\n/**\n* @return list of crawled pages\n*/\npublic List<Page> getCrawledPages()\n\n/**\n* Using the given url in the constructor it visits every resource that haves\n* the same host and crawls its data.\n* \n*/\npublic void crawl() Algolia Search For our custom search service in WebHelp we used Algolia and its API. How to connect HTML Crawler with Algolia and use it in WebHelp. Create an Algolia account by accesing: https://www.algolia.com Go to Settings and search for Application ID, Admin API Key and Search-Only API key. Save Application ID and Admin API Key to \"config.properties\" file in repository. We'll need the Seach-Only API key later. To create a new Index with crawled pages we use AlgoliaClient class and here's how to do it: AlgoliaClient client = new AlgoliaClient();\nclient.initIndex(indexName);\nclient.addObjectToIndex(url, baseUrl); We don't need to create a Crawler because AlgoliaClient uses its internal intstance of Crawler. We just need to send URL and baseURL into addObjectToIndex(url, baseUrl) method. The method will call the Crawler to crawl the sent URL and will post crawled pages into indexName on Algolia. After adding objects to our index we can use with Algolia search engine. Access your template folder for WebHelp Responsive. Create a new \"search.html\" file where we will connect our Algolia JS dependecies. It should look like this: <!DOCTYPE html>\n<html>\n    <head>\n        <script src=\"https://cdn.jsdelivr.net/npm/algoliasearch@4.5.1/dist/algoliasearch-lite.umd.js\"\n\t\tintegrity=\"sha256-EXPXz4W6pQgfYY3yTpnDa3OH8/EPn16ciVsPQ/ypsjk=\" crossorigin=\"anonymous\"></script>\n        <script src=\"https://cdn.jsdelivr.net/npm/instantsearch.js@4.8.3/dist/instantsearch.production.min.js\"\n\t\tintegrity=\"sha256-LAGhRRdtVoD6RLo2qDQsU2mp+XVSciKRC8XPOBWmofM=\" crossorigin=\"anonymous\"></script>\n        <script src=\"${oxygen-webhelp-template-dir}/js/algolia.js\"></script>\n    </head>\n    <body></body>\n</html> Create \"algolia.js\" file in the same directory. We'll use it to replace search engine. In order to connect this HTML file with JS source files we have to add these lines to our template:  <resources>\n            <fileset><include name=\"algolia.js\"/></fileset>\n </resources>\n <html-fragments>\n            <fragment file=\"search.html\" placeholder=\"webhelp.fragment.head\"/>\n </html-fragments> In algolia.js we have to disable current search engine and change it to our Algolia engine. // Connect and authenticate with your Algolia app\nconst searchClient = algoliasearch('your_app_id', 'your_search_only_api_key');\nconst searchInstance = instantsearch({\n\tindexName: your_index_name,\n\tsearchClient,\n\trouting: true,\n})\n\nconst algoliaSearch = {\n    performSearchOperation(query, successHandler, errorHandler){\n        const result = searchClient.initIndex(searchInstance.indexName).search(query);\n        result.then(obj => {\n            const meta = new WebHelpAPI.SearchMeta('Algolia', obj.nbHits, obj.page, obj.hitsPerPage, obj.nbPages, query, false, false, false, false, false, false);\n            \n            const documents = obj.hits.map(it => {\n                return new WebHelpAPI.SearchDocument(it.objectID, it.title, \"\", [], 0, [], []);\n            });\n\n            successHandler(new WebHelpAPI.SearchResult(meta, documents));\n        }).catch(error => {\n            console.log(error);\n        }) \n    },\n\n    onPageChangedHandler(pageToShow, query, successHandler, searchFailed){\n       const result = searchClient.initIndex(searchInstance.indexName).search(query, {\n        page: pageToShow,\n      });\n\n      result.then(obj => {\n        const meta = new WebHelpAPI.SearchMeta('Algolia', obj.nbHits, obj.page, obj.hitsPerPage, obj.nbPages, query, false, false, false, false, false, false);\n        \n        const documents = obj.hits.map(it => {\n            return new WebHelpAPI.SearchDocument(it.objectID, it.title, \"\", [], 0, [], []);\n        });\n\n        successHandler(new WebHelpAPI.SearchResult(meta, documents));\n    }).catch(error => {\n        console.log(error);\n    }) \n    }\n}\n\nWebHelpAPI.disableWebHelpDefaultSearchEngine();\nWebHelpAPI.setCustomSearchEngine(algoliaSearch);",
    "objectID": "https://sweet-beignet-8a9e20.netlify.app/topics/crawling_data_and_use_it_with_algolia.html"
  }
]